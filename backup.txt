# Isometric Roguelike Game using Pygame and External Sprites
# By Gemini (with Major Bug Fixes)

import pygame
import random
import math
import os
import level_designs # Import the new level designs file
from moviepy import VideoFileClip # Import for video playback

# --- Initialization ---
pygame.init()

# --- Screen and Display Setup ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Gemini's Roguelike")

# --- Colors ---
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
DARK_RED = (128, 0, 0)
GREEN = (0, 180, 0)
BLUE = (0, 100, 255)
DARK_BLUE = (0, 50, 150)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)
CYAN = (0, 255, 255)
ORANGE = (255, 165, 0)
GRAY = (128, 128, 128)


# --- Game Constants ---
TILE_WIDTH = 64
TILE_HEIGHT = 32
MAP_WIDTH = 35
MAP_HEIGHT = 35
MAX_LEVELS = 5
INVENTORY_CAPACITY = 9
EXPLORATION_REQUIREMENT = 0.8 # 80% of floor tiles must be explored to reveal key

# --- Fonts ---
font = pygame.font.Font(None, 22)
large_font = pygame.font.Font(None, 48)
help_font = pygame.font.Font(None, 24)


# --- Sprite Loading ---
SPRITES = {}

def load_and_scale_sprite(name, filename, scale_factor=1.0):
    """Loads an image, scales it, and stores it."""
    try:
        filepath = os.path.join(os.path.dirname(os.path.abspath(__file__)), filename)
        image = pygame.image.load(filepath).convert_alpha()
        
        original_width, original_height = image.get_size()
        new_width = int(TILE_WIDTH * scale_factor)
        new_height = int(original_height * new_width / original_width)
        
        SPRITES[name] = pygame.transform.scale(image, (new_width, new_height))
    except pygame.error as e:
        print(f"Unable to load sprite: {filename}. Error: {e}")
        SPRITES[name] = pygame.Surface((int(TILE_WIDTH * scale_factor), int(TILE_HEIGHT * scale_factor)))
        SPRITES[name].fill(RED)

# --- World to Screen Conversion ---
def to_screen_coords(map_x, map_y):
    """Converts map coordinates to screen coordinates for isometric view."""
    screen_x = (map_x - map_y) * (TILE_WIDTH / 2) + SCREEN_WIDTH / 2
    screen_y = (map_x + map_y) * (TILE_HEIGHT / 2) + 50
    return int(screen_x), int(screen_y)

# --- Game Components ---

class Tile:
    def __init__(self, blocked):
        self.blocked = blocked
        self.explored = False

class GameObject:
    def __init__(self, x, y, name, blocks=False, fighter=None, ai=None, item=None, light_source=None, equippable=None):
        self.x, self.y = x, y
        self.name = name
        self.blocks = blocks
        self.sprite = SPRITES.get(name)
        
        self.fighter = fighter
        if self.fighter: self.fighter.owner = self
        self.ai = ai
        if self.ai: self.ai.owner = self
        self.item = item
        if self.item: self.item.owner = self
        self.light_source = light_source
        if self.light_source: self.light_source.owner = self
        self.equippable = equippable
        if self.equippable: self.equippable.owner = self
        self.inventory = None
        self.equipment = None


    def move(self, dx, dy, game_map, objects):
        target_x, target_y = self.x + dx, self.y + dy
        if 0 <= target_x < MAP_WIDTH and 0 <= target_y < MAP_HEIGHT and not game_map[target_x][target_y].blocked:
            # Check for blocking objects like doors
            if not any(obj.blocks and obj.x == target_x and obj.y == target_y for obj in objects):
                self.x = target_x
                self.y = target_y

    def draw(self, surface, camera_offset_x, camera_offset_y):
        """Draws the object's sprite at its isometric position."""
        if self.sprite:
            screen_x, screen_y = to_screen_coords(self.x, self.y)
            sprite_rect = self.sprite.get_rect(midbottom=(screen_x, screen_y + TILE_HEIGHT / 2))
            surface.blit(self.sprite, (sprite_rect.x - camera_offset_x, sprite_rect.y - camera_offset_y))

class Fighter:
    def __init__(self, hp, defense, power, xp=0, level=1, mana=0, is_boss=False):
        self.base_max_hp, self.base_defense, self.base_power = hp, defense, power
        self.hp = hp
        self.xp = xp
        self.level = level
        self.current_xp = 0
        self.xp_to_next_level = 100 * level
        self.base_max_mana = mana
        self.mana = mana
        self.is_boss = is_boss

    @property
    def max_hp(self):
        if self.owner and self.owner.equipment:
            bonus = sum(e.max_hp_bonus for e in self.owner.equipment.get_all_equipped())
            return self.base_max_hp + bonus
        return self.base_max_hp

    @property
    def power(self):
        if self.owner and self.owner.equipment:
            bonus = sum(e.power_bonus for e in self.owner.equipment.get_all_equipped())
            return self.base_power + bonus
        return self.base_power

    @property
    def defense(self):
        if self.owner and self.owner.equipment:
            bonus = sum(e.defense_bonus for e in self.owner.equipment.get_all_equipped())
            return self.base_defense + bonus
        return self.base_defense
    
    @property
    def max_mana(self):
        if self.owner and self.owner.equipment:
            bonus = sum(e.max_mana_bonus for e in self.owner.equipment.get_all_equipped())
            return self.base_max_mana + bonus
        return self.base_max_mana

    def take_damage(self, damage, message_log):
        if damage > 0: self.hp -= damage
        if self.hp <= 0:
            message_log.add_message(f'{self.owner.name.capitalize()} dies!', RED)
            return self.xp, True  # Return XP and death flag
        return 0, False  # Return no XP and not dead

    def attack(self, target, message_log):
        damage = self.power - target.fighter.defense
        xp_gained = 0
        if damage > 0:
            message_log.add_message(f'{self.owner.name.capitalize()} attacks {target.name} for {damage} HP.', WHITE)
            xp_gained, is_dead = target.fighter.take_damage(damage, message_log)
        else:
            message_log.add_message(f'{self.owner.name.capitalize()} attacks {target.name} but has no effect!', (150,150,150))
        
        if xp_gained > 0 and self.owner.name == 'player':
            self.add_xp(xp_gained, message_log)

    def add_xp(self, xp, message_log):
        self.current_xp += xp
        if self.current_xp >= self.xp_to_next_level:
            self.level_up(message_log)

    def level_up(self, message_log):
        self.level += 1
        self.current_xp = 0
        self.xp_to_next_level = int(self.xp_to_next_level * 1.5)
        
        self.base_max_hp += 20
        self.base_power += 1
        self.base_defense += 1
        self.base_max_mana += 5
        self.hp = self.max_hp
        self.mana = self.max_mana
        
        message_log.add_message(f'You reached level {self.level}!', GOLD)

class BasicMonsterAI:
    def take_turn(self, target, fov_map, game_map, objects, message_log, dungeon_level, game_state):
        monster = self.owner
        if fov_map[monster.x][monster.y]:
            distance = math.sqrt((target.x - monster.x)**2 + (target.y - monster.y)**2)
            if distance >= 2:
                dx = target.x - monster.x
                dy = target.y - monster.y
                dx, dy = int(round(dx / distance)), int(round(dy / distance))
                
                target_x, target_y = monster.x + dx, monster.y + dy
                is_blocked = any(obj.x == target_x and obj.y == target_y and obj.blocks for obj in objects)
                if not is_blocked:
                    monster.move(dx, dy, game_map, objects)
            elif target.fighter.hp > 0:
                monster.fighter.attack(target, message_log)
                result = remove_dead_enemies(objects, message_log, dungeon_level)
                if result == 'VICTORY':
                    game_state = 'VICTORY'

class RangedMonsterAI(BasicMonsterAI):
    def __init__(self, max_range=5):
        self.max_range = max_range

    def take_turn(self, target, fov_map, game_map, objects, message_log, dungeon_level, game_state):
        monster = self.owner
        if fov_map[monster.x][monster.y]:
            distance = math.sqrt((target.x - monster.x)**2 + (target.y - monster.y)**2)
            if distance <= self.max_range and distance >= 2:
                message_log.add_message(f'The {monster.name} shoots at you!', RED)
                damage = monster.fighter.power - target.fighter.defense
                if damage > 0:
                    target.fighter.take_damage(damage, message_log)
                    result = remove_dead_enemies(objects, message_log, dungeon_level)
                    if result == 'VICTORY':
                        game_state = 'VICTORY'
            else:
                super().take_turn(target, fov_map, game_map, objects, message_log, dungeon_level, game_state)


class Item:
    def use(self, inventory, message_log, **kwargs):
        inventory.remove_item(self.owner)
        return 'used'

class HealingPotion(Item):
    def __init__(self, amount): self.amount = amount
    
    def use(self, inventory, message_log, **kwargs):
        if inventory.owner.fighter.hp == inventory.owner.fighter.max_hp:
            message_log.add_message('You are already at full health.', YELLOW)
            return 'cancelled'
        message_log.add_message('You drink the potion and feel better!', GREEN)
        inventory.owner.fighter.hp = min(inventory.owner.fighter.max_hp, inventory.owner.fighter.hp + self.amount)
        inventory.remove_item(self.owner)
        return 'used'

class Spell(Item):
    def __init__(self, name, mana_cost, damage, max_range):
        self.name, self.mana_cost, self.damage, self.max_range = name, mana_cost, damage, max_range

    def use(self, inventory, message_log, target_x=None, target_y=None, objects=None, dungeon_level=None, game_state=None):
        player = inventory.owner
        if player.fighter.mana < self.mana_cost:
            message_log.add_message('Not enough mana.', RED)
            return 'cancelled'
        
        if target_x is None: return 'targeting'

        player.fighter.mana -= self.mana_cost
        target = next((obj for obj in objects if obj.fighter and obj.x == target_x and obj.y == target_y), None)
        if target:
            message_log.add_message(f'A {self.name} engulfs the {target.name} for {self.damage} damage!', ORANGE)
            target.fighter.take_damage(self.damage, message_log)
            result = remove_dead_enemies(objects, message_log, dungeon_level)
            if result == 'VICTORY':
                game_state = 'VICTORY'
        else:
            message_log.add_message(f'The {self.name} fizzles out.', GRAY)
        
        return 'used'


class Equippable:
    def __init__(self, slot, power_bonus=0, defense_bonus=0, max_hp_bonus=0, max_mana_bonus=0):
        self.slot, self.power_bonus, self.defense_bonus, self.max_hp_bonus, self.max_mana_bonus = slot, power_bonus, defense_bonus, max_hp_bonus, max_mana_bonus

class Equipment:
    def __init__(self, owner):
        self.owner = owner
        self.main_hand, self.off_hand, self.body = None, None, None

    def get_all_equipped(self):
        equipped = []
        if self.main_hand: equipped.append(self.main_hand.equippable)
        if self.off_hand: equipped.append(self.off_hand.equippable)
        if self.body: equipped.append(self.body.equippable)
        return equipped

    def toggle_equip(self, equippable_item, message_log):
        slot = equippable_item.equippable.slot
        currently_equipped = None
        if slot == 'main_hand': currently_equipped = self.main_hand
        elif slot == 'off_hand': currently_equipped = self.off_hand
        elif slot == 'body': currently_equipped = self.body

        if currently_equipped == equippable_item:
            if slot == 'main_hand': self.main_hand = None
            elif slot == 'off_hand': self.off_hand = None
            elif slot == 'body': self.body = None
            message_log.add_message(f'You unequip the {equippable_item.name}.')
            self.owner.inventory.add_item(equippable_item, message_log)
        else:
            if currently_equipped: self.owner.inventory.add_item(currently_equipped, message_log)
            
            if slot == 'main_hand': self.main_hand = equippable_item
            elif slot == 'off_hand': self.off_hand = equippable_item
            elif slot == 'body': self.body = equippable_item
            message_log.add_message(f'You equip the {equippable_item.name}.')


class Inventory:
    def __init__(self, owner, capacity):
        self.owner, self.capacity, self.items = owner, capacity, []

    def add_item(self, item, message_log):
        if len(self.items) >= self.capacity:
            message_log.add_message('Your inventory is full.', RED)
        else:
            message_log.add_message(f'You picked up the {item.name}!', GREEN)
            self.items.append(item)
    
    def use(self, item_to_use, message_log, **kwargs):
        if item_to_use.item:
            return item_to_use.item.use(self, message_log, **kwargs)
        elif item_to_use.equippable:
            self.owner.equipment.toggle_equip(item_to_use, message_log)
            self.remove_item(item_to_use)
            return 'used'
        else:
            message_log.add_message(f'The {item_to_use.name} cannot be used or equipped.', YELLOW)
            return 'cancelled'

    def remove_item(self, item):
        if item in self.items: self.items.remove(item)

class LightSource:
    def __init__(self, radius): self.radius = radius

class MessageLog:
    def __init__(self, x, y, width, height):
        self.messages, self.x, self.y, self.width, self.height = [], x, y, width, height

    def add_message(self, text, color=WHITE):
        self.messages.append((text, color))
        if len(self.messages) > self.height: del self.messages[0]

    def draw(self, surface):
        bg_rect = pygame.Rect(self.x, self.y, self.width, self.height * font.get_height() + 10)
        s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
        s.fill((20, 20, 20, 180))
        surface.blit(s, bg_rect.topleft)

        y = self.y + 5
        for message, color in self.messages:
            surface.blit(font.render(message, True, color), (self.x + 5, y))
            y += font.get_height()

# --- Map Generation ---
def make_map(player, level):
    game_map = [[Tile(True) for _ in range(MAP_HEIGHT)] for _ in range(MAP_WIDTH)]
    objects = [player]
    
    layout = level_designs.LEVEL_DATA.get(level, level_designs.LEVEL_DATA[1])
    
    layout_width, layout_height = len(layout[0]), len(layout)
    start_x, start_y = (MAP_WIDTH - layout_width) // 2, (MAP_HEIGHT - layout_height) // 2
    
    spawns = {'m': [], 'i': [], 'D': [], 'K': [], 'B': [], 'S': [], 'X': []}
    total_floor_tiles = 0

    for y, row in enumerate(layout):
        for x, char in enumerate(row):
            map_x, map_y = start_x + x, start_y + y
            if char == '#':
                game_map[map_x][map_y] = Tile(True)
            else:
                game_map[map_x][map_y] = Tile(False)
                total_floor_tiles += 1
                if char == 'P': player.x, player.y = map_x, map_y
                elif char in spawns: spawns[char].append((map_x, map_y))

    place_objects(spawns, objects, level)
    return game_map, objects, total_floor_tiles

def place_objects(spawns, objects, level):
    # Bosses
    boss_list = {1: 'gargoyle', 2: 'fenrir', 3: 'chimera', 4: 'hydra', 5: 'dragon'}
    boss_name = boss_list.get(level)
    if boss_name and spawns['B']:
        x, y = spawns['B'][0]
        hp = 100 * level
        power = 10 + 2 * level
        defense = 5 + level
        xp = 200 * level
        fighter = Fighter(hp, defense, power, xp, is_boss=True)
        boss = GameObject(x, y, boss_name, True, fighter, BasicMonsterAI())
        objects.append(boss)

    # Place other objects
    for m_x, m_y in spawns['m']:
        if random.random() < 0.6: # Chance to spawn a monster
            # Monster spawning logic
            monster_types = ['goblin', 'slime', 'bat', 'skeleton']
            if level >= 2:
                monster_types.append('goblin_archer')
            monster_name = random.choice(monster_types)
            
            # Adjust stats based on level
            hp = 20 + level * 5
            defense = level
            power = 3 + level
            xp = 10 + level * 5
            
            # Choose AI based on monster type
            if monster_name == 'goblin_archer':
                fighter = Fighter(hp, defense, power, xp)
                ai = RangedMonsterAI(max_range=5)
            else:
                fighter = Fighter(hp, defense, power, xp)
                ai = BasicMonsterAI()
                
            monster = GameObject(m_x, m_y, monster_name, True, fighter, ai)
            objects.append(monster)
    for i_x, i_y in spawns['i']:
        if random.random() < 0.4: # Chance to spawn an item
            # Item spawning logic
            item_types = ['potion', 'chest']
            equipment_types = ['sword', 'shield', 'armor', 'staff', 'bow']
            
            # Higher chance for equipment on later levels
            if level >= 2 and random.random() < 0.3:
                item_name = random.choice(equipment_types)
                if item_name == 'sword':
                    item = GameObject(i_x, i_y, item_name, equippable=Equippable('main_hand', power_bonus=3))
                elif item_name == 'shield':
                    item = GameObject(i_x, i_y, item_name, equippable=Equippable('off_hand', defense_bonus=2))
                elif item_name == 'armor':
                    item = GameObject(i_x, i_y, item_name, equippable=Equippable('body', defense_bonus=3, max_hp_bonus=20))
                elif item_name == 'staff':
                    item = GameObject(i_x, i_y, item_name, equippable=Equippable('main_hand', power_bonus=2, max_mana_bonus=10))
                elif item_name == 'bow':
                    item = GameObject(i_x, i_y, item_name, equippable=Equippable('main_hand', power_bonus=2))
                    # Add arrows for bow
                    arrow = GameObject(i_x, i_y, 'arrow', item=Item())
                    objects.append(arrow)
            else:
                item_name = random.choice(item_types)
                if item_name == 'potion':
                    item = GameObject(i_x, i_y, item_name, item=HealingPotion(20))
                else: # chest
                    item = GameObject(i_x, i_y, item_name)
            objects.append(item)
    for d_x, d_y in spawns['D']: objects.append(GameObject(d_x, d_y, 'door', True))
    for k_x, k_y in spawns['K']: objects.append(GameObject(k_x, k_y, 'key'))
    for x_x, x_y in spawns['X']: objects.append(GameObject(x_x, x_y, 'princess', True))
    for s_x, s_y in spawns['S']: objects.append(GameObject(s_x, s_y, 'stairs'))
    
    # Hide key, princess, and stairs initially
    for obj in objects:
        if obj.name in ['key', 'princess', 'stairs']:
            obj.sprite = None 

# --- Field of View & Lighting ---
FOV_RADIUS = 8
def compute_fov_and_lighting(game_map, objects, player):
    fov_map = [[False for _ in range(MAP_HEIGHT)] for _ in range(MAP_WIDTH)]
    light_map = [[0.0 for _ in range(MAP_HEIGHT)] for _ in range(MAP_WIDTH)]
    
    for angle in range(360):
        rad = math.radians(angle)
        for i in range(FOV_RADIUS * 2):
            dist = i / 2.0
            x, y = int(player.x + dist * math.cos(rad) + 0.5), int(player.y + dist * math.sin(rad) + 0.5)
            if 0 <= x < MAP_WIDTH and 0 <= y < MAP_HEIGHT:
                fov_map[x][y] = True
                game_map[x][y].explored = True
                if game_map[x][y].blocked: break
    
    light_sources = [p.light_source for p in [player] + objects if p.light_source]
    for source in light_sources:
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                dist = math.sqrt((x - source.owner.x)**2 + (y - source.owner.y)**2)
                if dist < source.radius:
                    falloff = (1 - (dist / source.radius))**2
                    light_map[x][y] = max(light_map[x][y], falloff)

    return fov_map, light_map

# --- Drawing ---
def draw_all(surface, game_map, objects, player, fov_map, light_map, message_log, game_state, dungeon_level, targeting_mode, target_pos):
    cam_x, cam_y = to_screen_coords(player.x, player.y)
    camera_offset_x = cam_x - SCREEN_WIDTH / 2
    camera_offset_y = cam_y - SCREEN_HEIGHT / 2

    surface.fill(BLACK)

    sorted_objects = sorted(objects + [player], key=lambda obj: obj.x + obj.y + (1 if obj.blocks else 0))

    for y in range(MAP_HEIGHT):
        for x in range(MAP_WIDTH):
            if fov_map[x][y] or game_map[x][y].explored:
                screen_x, screen_y = to_screen_coords(x, y)
                sprite = SPRITES['wall'] if game_map[x][y].blocked else SPRITES['floor']
                rect = sprite.get_rect(center=(screen_x, screen_y))
                
                brightness = light_map[x][y] if fov_map[x][y] else 0.2 if game_map[x][y].explored else 0
                temp_sprite = sprite.copy()
                temp_sprite.fill((brightness*255, brightness*255, brightness*255), special_flags=pygame.BLEND_RGB_MULT)
                surface.blit(temp_sprite, (rect.x - camera_offset_x, rect.y - camera_offset_y))

    for obj in sorted_objects:
        if fov_map[obj.x][obj.y]:
            obj.draw(surface, camera_offset_x, camera_offset_y)

    if targeting_mode:
        tx, ty = to_screen_coords(target_pos[0], target_pos[1])
        pygame.draw.circle(surface, CYAN, (tx - camera_offset_x, ty - camera_offset_y), TILE_HEIGHT, 2)

    # --- HUD ---
    draw_hud(surface, player, message_log, dungeon_level, objects, fov_map)
    
    if game_state == 'HELP_MENU':
        draw_help_menu(surface)
    elif game_state in ['GAME_OVER', 'VICTORY', 'LEVEL_UP_TRANSITION']:
        msg = {'GAME_OVER': 'GAME OVER', 'VICTORY': 'YOU WIN!', 'LEVEL_UP_TRANSITION': 'You descend deeper...'}[game_state]
        color = {'GAME_OVER': DARK_RED, 'VICTORY': GREEN, 'LEVEL_UP_TRANSITION': YELLOW}[game_state]
        text = large_font.render(msg, True, color)
        surface.blit(text, text.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2)))

def draw_hud(surface, player, message_log, dungeon_level, objects, fov_map):
    # Player Status
    avatar_bg_rect = pygame.Rect(10, 10, 280, 140)
    s = pygame.Surface(avatar_bg_rect.size, pygame.SRCALPHA)
    s.fill((20, 20, 20, 200))
    surface.blit(s, avatar_bg_rect.topleft)
    
    player_avatar = pygame.transform.scale(SPRITES['player'], (60, 60))
    surface.blit(player_avatar, (20, 25))
    
    level_text = font.render(f'LEVEL: {player.fighter.level}', True, WHITE)
    surface.blit(level_text, (90, 15))
    
    bar_width = 180
    hp_bar_x, hp_bar_y = 90, 40
    current_hp_width = int(player.fighter.hp / player.fighter.max_hp * bar_width)
    pygame.draw.rect(surface, DARK_RED, (hp_bar_x, hp_bar_y, bar_width, 20))
    if current_hp_width > 0: pygame.draw.rect(surface, RED, (hp_bar_x, hp_bar_y, current_hp_width, 20))
    hp_text = font.render(f'HP: {player.fighter.hp}/{player.fighter.max_hp}', True, WHITE)
    surface.blit(hp_text, (hp_bar_x + 5, hp_bar_y + 2))

    mana_bar_y = 65
    current_mana_width = int(player.fighter.mana / player.fighter.max_mana * bar_width) if player.fighter.max_mana > 0 else 0
    pygame.draw.rect(surface, DARK_BLUE, (hp_bar_x, mana_bar_y, bar_width, 15))
    if current_mana_width > 0: pygame.draw.rect(surface, BLUE, (hp_bar_x, mana_bar_y, current_mana_width, 15))
    mana_text = font.render(f'MANA: {player.fighter.mana}/{player.fighter.max_mana}', True, WHITE)
    surface.blit(mana_text, (hp_bar_x + 5, mana_bar_y))

    xp_bar_y = 85
    if player.fighter.xp_to_next_level > 0:
      current_xp_width = int(player.fighter.current_xp / player.fighter.xp_to_next_level * bar_width)
    else:
      current_xp_width = 0
    pygame.draw.rect(surface, (50, 50, 0), (hp_bar_x, xp_bar_y, bar_width, 15))
    if current_xp_width > 0: pygame.draw.rect(surface, GOLD, (hp_bar_x, xp_bar_y, current_xp_width, 15))
    xp_text = font.render(f'XP: {player.fighter.current_xp}/{player.fighter.xp_to_next_level}', True, WHITE)
    surface.blit(xp_text, (hp_bar_x + 5, xp_bar_y))

    atk_text = font.render(f'ATK: {player.fighter.power}', True, WHITE)
    def_text = font.render(f'DEF: {player.fighter.defense}', True, WHITE)
    surface.blit(atk_text, (hp_bar_x, xp_bar_y + 20))
    surface.blit(def_text, (hp_bar_x + 80, xp_bar_y + 20))

    dungeon_level_text = font.render(f'Dungeon Level: {dungeon_level}', True, YELLOW)
    surface.blit(dungeon_level_text, (10, 160))

    # Boss HP Bar
    current_boss = next((obj for obj in objects if obj.fighter and obj.fighter.is_boss), None)
    if current_boss and fov_map[current_boss.x][current_boss.y]:
        boss_bar_width = 400
        boss_bar_x = (SCREEN_WIDTH - boss_bar_width) / 2
        boss_bar_y = 10
        current_boss_hp_width = int(current_boss.fighter.hp / current_boss.fighter.max_hp * boss_bar_width)
        pygame.draw.rect(surface, DARK_RED, (boss_bar_x, boss_bar_y, boss_bar_width, 20))
        if current_boss_hp_width > 0: pygame.draw.rect(surface, RED, (boss_bar_x, boss_bar_y, current_boss_hp_width, 20))
        boss_name_text = large_font.render(current_boss.name.capitalize(), True, WHITE)
        surface.blit(boss_name_text, (boss_bar_x + 5, boss_bar_y - 5))


    # Inventory Bar
    slot_size = 50
    inv_bar_width = (slot_size + 10) * INVENTORY_CAPACITY
    inv_bar_x = (SCREEN_WIDTH - inv_bar_width) / 2
    inv_bar_y = SCREEN_HEIGHT - slot_size - 10
    
    for i in range(INVENTORY_CAPACITY):
        slot_x = inv_bar_x + i * (slot_size + 10)
        slot_rect = pygame.Rect(slot_x, inv_bar_y, slot_size, slot_size)
        
        surface.blit(SPRITES['inventory_slot'], slot_rect)
        
        if i < len(player.inventory.items):
            item_sprite = SPRITES[player.inventory.items[i].name]
            item_rect = item_sprite.get_rect(center=slot_rect.center)
            surface.blit(item_sprite, item_rect)
        
        num_text = font.render(str(i+1), True, WHITE)
        surface.blit(num_text, (slot_x + 2, inv_bar_y + 2))

    message_log.width = inv_bar_width
    message_log.height = 4
    message_log.x = inv_bar_x
    message_log.y = inv_bar_y - (message_log.height * font.get_height() + 15)
    message_log.draw(surface)
    
    help_text_render = font.render("Press / for Help", True, GRAY)
    surface.blit(help_text_render, (SCREEN_WIDTH - help_text_render.get_width() - 10, SCREEN_HEIGHT - help_text_render.get_height() - 10))


def draw_help_menu(surface):
    """Draws the help menu overlay."""
    menu_width = 400
    menu_height = 300
    menu_x = (SCREEN_WIDTH - menu_width) / 2
    menu_y = (SCREEN_HEIGHT - menu_height) / 2
    
    s = pygame.Surface((menu_width, menu_height), pygame.SRCALPHA)
    s.fill((20, 20, 20, 220))
    surface.blit(s, (menu_x, menu_y))

    title_text = large_font.render("Controls", True, GOLD)
    surface.blit(title_text, (menu_x + (menu_width - title_text.get_width()) / 2, menu_y + 20))

    controls = [
        ("Move:", "Arrow Keys or HJKL"),
        ("Pick Up Item:", "G"),
        ("Use/Equip Item:", "1 - 9"),
        ("Descend Stairs:", ". (Period)"),
        ("Use Magic/Ranged:", "F (to target)"),
        ("  - Move Target:", "Arrow Keys"),
        ("  - Confirm:", "Enter"),
        ("  - Cancel:", "Escape"),
        ("Toggle Help:", "/ (Slash)"),
        ("Close Menu:", "/ or Escape"),
    ]

    y_offset = 80
    for action, key in controls:
        action_text = help_font.render(action, True, WHITE)
        key_text = help_font.render(key, True, YELLOW)
        surface.blit(action_text, (menu_x + 20, menu_y + y_offset))
        surface.blit(key_text, (menu_x + 200, menu_y + y_offset))
        y_offset += 25

# Princess interaction now plays video directly, so this function is no longer needed
# def play_victory_video(surface):
#     """Loads and plays the victory video."""
#     try:
#         video_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'assets/victory.mov')
#         clip = VideoFileClip(video_path)
#         clip.preview()
#         # After playing the video, return 'EXIT' to end the game
#         return 'EXIT'
#     except Exception as e:
#         print(f"Could not play video: {e}")
#         # Skip to exit if video fails
#         return 'EXIT'

# --- Game Loop ---
def handle_keys(player, objects, game_map, message_log, game_state, targeting_mode, target_pos, item_to_use, dungeon_level, game_state_main):
    for event in pygame.event.get():
        if event.type == pygame.QUIT: return 'exit', game_state, targeting_mode, target_pos, item_to_use
        if event.type == pygame.KEYDOWN:
            if game_state == 'HELP_MENU':
                if event.key == pygame.K_SLASH or event.key == pygame.K_ESCAPE:
                    return 'did-nothing', 'PLAYING', False, [0,0], None
            elif targeting_mode:
                if event.key == pygame.K_UP: target_pos[1] -= 1
                elif event.key == pygame.K_DOWN: target_pos[1] += 1
                elif event.key == pygame.K_LEFT: target_pos[0] -= 1
                elif event.key == pygame.K_RIGHT: target_pos[0] += 1
                elif event.key == pygame.K_RETURN:
                    player.inventory.use(item_to_use, message_log, target_x=target_pos[0], target_y=target_pos[1], objects=objects, dungeon_level=dungeon_level, game_state=game_state_main)
                    return 'player-turn', 'PLAYING', False, [0,0], None
                elif event.key == pygame.K_ESCAPE:
                    return 'did-nothing', 'PLAYING', False, [0,0], None
            elif game_state == 'PLAYING':
                action = 'player-turn'
                if event.key in (pygame.K_UP, pygame.K_k): game_state = player_move_or_attack(0, -1, player, objects, game_map, message_log, dungeon_level, game_state_main)
                elif event.key in (pygame.K_DOWN, pygame.K_j): game_state = player_move_or_attack(0, 1, player, objects, game_map, message_log, dungeon_level, game_state_main)
                elif event.key in (pygame.K_LEFT, pygame.K_h): game_state = player_move_or_attack(-1, 0, player, objects, game_map, message_log, dungeon_level, game_state_main)
                elif event.key in (pygame.K_RIGHT, pygame.K_l): game_state = player_move_or_attack(1, 0, player, objects, game_map, message_log, dungeon_level, game_state_main)
                elif event.key == pygame.K_g:
                    for obj in objects:
                        if obj.x == player.x and obj.y == player.y and (obj.item or obj.equippable):
                            player.inventory.add_item(obj, message_log)
                            objects.remove(obj)
                            break
                elif event.key >= pygame.K_1 and event.key <= pygame.K_9:
                    item_index = event.key - pygame.K_1
                    if item_index < len(player.inventory.items):
                        item = player.inventory.items[item_index]
                        result = player.inventory.use(item, message_log, objects=objects, dungeon_level=dungeon_level, game_state=game_state_main)
                        if result == 'targeting':
                            targeting_mode = True
                            target_pos = [player.x, player.y]
                            item_to_use = item
                elif event.key == pygame.K_f: # Use equipped spell
                    if player.equipment.main_hand and isinstance(player.equipment.main_hand.item, Spell):
                        targeting_mode = True
                        target_pos = [player.x, player.y]
                        item_to_use = player.equipment.main_hand
                elif event.key == pygame.K_SLASH:
                    game_state = 'HELP_MENU'
                elif event.key == pygame.K_PERIOD:
                    # Check if player is on stairs
                    if any(o.name == 'stairs' and o.x == player.x and o.y == player.y for o in objects):
                        game_state = 'LEVEL_UP'
                    # Check if player is adjacent to princess (including same tile) and she's interactable
                    elif any(o.name == 'princess' and abs(o.x - player.x) <= 1 and abs(o.y - player.y) <= 1 and getattr(o, 'interactable', False) for o in objects):
                        # Play the victory video directly
                        # REPLACE IT WITH THIS CORRECTED BLOCK
                        # Attempt to play the victory video without quitting the main game window
                        try:
                            video_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'assets/victory.mp4')
                            clip = VideoFileClip(video_path)
                            clip.preview()
                        except Exception as e:
                            print(f"Could not play video: {e}. Showing victory screen instead.")

                        # After attempting the video, show the victory screen
                        game_state = 'VICTORY'
                else: action = 'did-nothing'
                return action, game_state, targeting_mode, target_pos, item_to_use
    return 'did-nothing', game_state, targeting_mode, target_pos, item_to_use

def player_move_or_attack(dx, dy, player, objects, game_map, message_log, dungeon_level, game_state):
    x, y = player.x + dx, player.y + dy
    target = next((obj for obj in objects if obj.fighter and obj.x == x and obj.y == y), None)
    if target:
        player.fighter.attack(target, message_log)
        result = remove_dead_enemies(objects, message_log, dungeon_level)
        if result == 'VICTORY':
            game_state = 'VICTORY'
    else: player.move(dx, dy, game_map, objects)
    return game_state
def remove_dead_enemies(objects, message_log, dungeon_level):
    """Remove dead enemies from the objects list."""
    # Create a list of objects to remove
    to_remove = []
    for obj in objects:
        if obj.fighter and obj.fighter.hp <= 0 and obj.name != 'player':
            to_remove.append(obj)
    
    # Remove the dead enemies
    for obj in to_remove:
        # Check if the dead enemy is a boss
        if obj.fighter and obj.fighter.is_boss:
            # Special case for the dragon (level 5 boss)
            if dungeon_level == 5 and obj.name == 'dragon':
                # Find the princess and make her visible
                princess = next((o for o in objects if o.name == 'princess'), None)
                if princess:
                    princess.sprite = SPRITES.get('princess')
                    # Add a flag to indicate princess is freed and can be interacted with
                    princess.interactable = True
                    message_log.add_message(f'The dragon collapses, and the princess is freed!', GOLD)
                    # Add a temporary light source to illuminate the area
                    # Create a temporary light source at the dragon's location with a large radius
                    temp_light = GameObject(obj.x, obj.y, 'temp_light', light_source=LightSource(radius=50))
                    objects.append(temp_light)
            else:
                # Create stairs at the boss's location for other bosses
                stairs = GameObject(obj.x, obj.y, 'stairs')
                # Make sure the stairs are visible (not hidden like initial stairs)
                stairs.sprite = SPRITES.get('stairs')
                objects.append(stairs)
                message_log.add_message(f'The {obj.name} collapses, revealing a staircase!', GOLD)
        
        if obj in objects:
            objects.remove(obj)
    
    # Return default value if no special action taken
    return None

def main():
    global stairs
    
    # Load all sprites
    load_and_scale_sprite('player', 'assets/player.png', 0.9)
    load_and_scale_sprite('goblin', 'assets/goblin.png', 0.7)
    load_and_scale_sprite('goblin_archer', 'assets/goblin_archer.png', 0.7)
    load_and_scale_sprite('slime', 'assets/slime.png', 0.8)
    load_and_scale_sprite('bat', 'assets/bat.png', 0.6)
    load_and_scale_sprite('skeleton', 'assets/skeleton.png', 0.8)
    load_and_scale_sprite('potion', 'assets/potion.png')
    load_and_scale_sprite('chest', 'assets/chest.png')
    load_and_scale_sprite('floor', 'assets/floor.png')
    load_and_scale_sprite('wall', 'assets/wall.png')
    load_and_scale_sprite('stairs', 'assets/stairs.png')
    load_and_scale_sprite('barrel', 'assets/barrel.png', 0.5)
    load_and_scale_sprite('crate', 'assets/crate.png', 0.5)
    load_and_scale_sprite('torch', 'assets/torch.png', 0.2)
    load_and_scale_sprite('sword', 'assets/sword.png', 0.3)
    load_and_scale_sprite('shield', 'assets/shield.png', 0.7)
    load_and_scale_sprite('armor', 'assets/armor.png', 0.7)
    load_and_scale_sprite('staff', 'assets/staff.png', 0.5)
    load_and_scale_sprite('inventory_slot', 'assets/inventory_slot.png', 1.0)
    load_and_scale_sprite('fireball', 'assets/fireball.png', 0.5)
    load_and_scale_sprite('arrow', 'assets/arrow.png', 0.3)
    load_and_scale_sprite('bow', 'assets/bow.png', 0.5)
    load_and_scale_sprite('gargoyle', 'assets/gargoyle.png', 1.0)
    load_and_scale_sprite('fenrir', 'assets/fenrir.png', 1.5)
    load_and_scale_sprite('chimera', 'assets/chimera.png', 1.5)
    load_and_scale_sprite('hydra', 'assets/hydra.png', 1.5)
    load_and_scale_sprite('dragon', 'assets/dragon.png', 1.8)
    load_and_scale_sprite('princess', 'assets/princess.png', 0.5)
    load_and_scale_sprite('key', 'assets/key.png', 0.5)
    load_and_scale_sprite('door', 'assets/door.png', 1.0)


    fighter_component = Fighter(1000, 1, 50, mana=20)
    inventory_component = Inventory(None, INVENTORY_CAPACITY)
    equipment_component = Equipment(None)
    player = GameObject(0, 0, 'player', True, fighter_component, light_source=LightSource(radius=8))
    player.inventory = inventory_component; player.inventory.owner = player
    player.equipment = equipment_component; player.equipment.owner = player
    
    dungeon_level = 1
    game_map, objects, total_floor_tiles = make_map(player, dungeon_level)
    
    message_log = MessageLog(0, 0, 0, 0)
    message_log.add_message('Welcome! Press / for help.', YELLOW)
    game_state = 'PLAYING'
    targeting_mode = False
    target_pos = [0, 0]
    item_to_use = None
    
    running = True
    while running:
        fov_map, light_map = compute_fov_and_lighting(game_map, objects, player)
        draw_all(screen, game_map, objects, player, fov_map, light_map, message_log, game_state, dungeon_level, targeting_mode, target_pos)
        pygame.display.flip()

        player_action, game_state, targeting_mode, target_pos, item_to_use = handle_keys(player, objects, game_map, message_log, game_state, targeting_mode, target_pos, item_to_use, dungeon_level, game_state)
        if player_action == 'exit': running = False
            
        if game_state == 'LEVEL_UP':
            dungeon_level += 1
            if dungeon_level > MAX_LEVELS: game_state = 'VICTORY'
            else:
                game_state = 'LEVEL_UP_TRANSITION'
                draw_all(screen, game_map, objects, player, fov_map, light_map, message_log, game_state, dungeon_level, targeting_mode, target_pos)
                pygame.display.flip()
                pygame.time.wait(1500)
                
                game_map, objects, total_floor_tiles = make_map(player, dungeon_level)
                message_log.add_message('You descend deeper...', YELLOW)
                game_state = 'PLAYING'

        if game_state == 'PLAYING' and player_action == 'player-turn':
            # Game logic updates - Monster turns
            for obj in objects:
                if obj.ai and obj != player:
                    obj.ai.take_turn(player, fov_map, game_map, objects, message_log, dungeon_level, game_state)
                    # Check if player is dead after each monster turn
                    if player.fighter.hp <= 0:
                        game_state = 'GAME_OVER'
                        break

    while game_state in ['GAME_OVER', 'VICTORY']:
        for event in pygame.event.get():
            if event.type == pygame.QUIT or event.type == pygame.KEYDOWN:
                game_state = 'EXIT'
        
        if game_state == 'VICTORY':
            draw_all(screen, game_map, objects, player, fov_map, light_map, message_log, game_state, dungeon_level, targeting_mode, target_pos)
            pygame.display.flip()

    pygame.quit()

if __name__ == '__main__':
    main()

Test Level Designs

# This file contains the static level layouts for the roguelike game.
# '#' = Wall
# '.' = Floor
# 'P' = Player Start
# 'S' = Stairs Spawn Location
# 'm' = Potential Monster Spawn
# 'i' = Potential Item Spawn
# 'D' = Door to Boss Room
# 'K' = Key Spawn Location
# 'B' = Boss Spawn Location
# 'X' = Princess Spawn Location

LEVEL_DATA = {
    1: [
        "####################",
        "#P i m...........i.#",
        "#####.############.#",
        "#...#.#m.........#.#",
        "#.###.#.########.#.#",
        "#.#...#.#......#.#.#",
        "#.#.###.#.####.#...#",
        "#.#.#...#....#.#..D#",
        "#...#...m....#..B.S#",
        "#.K.###########....#",
        "####################",
    ],
    2: [
        "#######################",
        "#P..m.................#",
        "#.#####..#..#######.###",
        "#.#...#..#..#.....#.#i#",
        "#.#.###..#..#.###.#.###",
        "#.#...#..#..#.#m#.#...#",
        "#i..m.#..#..#.#.#.##.D#",
        "#######..#..#.#.#....B#",
        "#........#..#...#....S#",
        "#.########..#####.#####",
        "#....m.....K........#.#",
        "#######################",
    ],
    3: [
        "##########################",
        "#P.m......#............i.#",
        "#.######..#.##########.###",
        "#......#..#..........#...#",
        "#####..#..##########.#.###",
        "#...#..#...........#.#.#i#",
        "#.#.#..#..##..#####..#.#.#",
        "#.#.#..#...#..#...#..#.#.#",
        "#.#....#...#..#...#..#...#",
        "#.#.####m.####m####..#####",
        "#.#....#........#........#",
        "#i..m..#...S....#....m...#",
        "#######D..################",
        "#K.....B.................#",
        "##########################",
    ],
    4: [
        "############################",
        "#P..m..i..#..............m.#",
        "#.#######.#.##############.#",
        "#.#.....#.#.#............#.#",
        "#.#.###.#.#.#.##########.#.#",
        "#...#...#...#.#........#.#.#",
        "###.#.###..##.#.########.#.#",
        "#...#.......#...#........#.#",
        "#.#########.###.##########.#",
        "#.#m......#.#...#........#.#",
        "#.#.######..#...#..#######.#",
        "#.#......#..#...#..#.....#.#",
        "#i#######D..B..S##..#..m..#.#",
        "#.........m.#......#..K..#.#",
        "############################",
    ],
    5: [
        "############################",
        "#P..m....m....m....m....m..#",
        "#.########################.#",
        "#.#i.....................#.#",
        "#.#######################.##",
        "#........................i##",
        "##.########################.",
        "##.#.....................#.#",
        "##.#####################.#.#",
        "##.....................#.#.#",
        "###.###################.#.##",
        "###..i....................##",
        "###.###################D#..#",
        "###..K....B....X....S......#",
        "############################",
    ]
}

Correct Level designs

# This file contains the static level layouts for the roguelike game.
# '#' = Wall
# '.' = Floor
# 'P' = Player Start
# 'S' = Stairs Spawn Location
# 'm' = Potential Monster Spawn
# 'i' = Potential Item Spawn
# 'D' = Door to Boss Room
# 'K' = Key Spawn Location
# 'B' = Boss Spawn Location
# 'X' = Princess Spawn Location

LEVEL_DATA = {
    1: [
        "#####################",
        "#P.i.m..m..i........#",
        "#.#####.##########.##",
        "#.#.i.#.#.m....#.#..#",
        "#.#.#.#.#.######.#.##",
        "#.#.#.i.#......#.#..#",
        "#.#.##########.#.#.##",
        "#.#.m........#.#.#.i#",
        "#.############.#.#.##",
        "#.i..........m.#.K..#",
        "##################D##",
        "#.m...............i.#",
        "#..B.S###############",
        "#####################",
    ],
    2: [
        "#######################",
        "#P..m..i.m..i........#",
        "#.#####.#####.#####.#.#",
        "#.#.i.#.#.m.#.#.i...#.#",
        "#.#.#.#.#.###.#.#.###.#",
        "#.#.#.i.#.....#.#...#.#",
        "#.#.#############.###.#",
        "#.#.m...........#.#.i.#",
        "#.#.###########.#.#.#.#",
        "#.#.i.........m.#.K...#",
        "########..#######D#####",
        "#.m............##.....#",
        "#.#####..###.###..B.S.#",
        "################......#",
        "#######################",
    ],
    3: [
        "##########################",
        "#P.m.i.m.i..............#",
        "#.#####.#####.#########.##",
        "#.#.i.#.#.m.#.#.i.....#..#",
        "#.#.#.#.#.#.#.#.#.#####.##",
        "#.#.#.i.#.#.i.#.#.....#.#",
        "#.#.#####.#####.#.#####.#",
        "#.#.m.........m.#.#...#.#",
        "#.#.###########.#.#.#.#.#",
        "#.#.i.........m.#.K...#.#",
        "#####.###########.#.#####",
        "#.m.....i.......#.#.....#",
        "#..B.S#############.#####",
        "##########################",
    ],
    4: [
        "############################",
        "#P..m..i.m..i.m..i........#",
        "#.#####.#####.#####.#######.#",
        "#.#.i.#.#.m.#.#.i.#.#.i...#.#",
        "#.#.#.#.#.#.#.#.#.#.#.#.###.#",
        "#.#.#.i.#.#.i.#.#.i.#.#...#.#",
        "#.#.#####.#####.#####.#.###.#",
        "#.#.m.....m.....m.....#.#.i.#",
        "#.#.###############.###.#.#.#",
        "#.#.i...........m.#.....K...#",
        "#####.###########.#.#########",
        "#.m.....i.......#.#.........#",
        "#..B.S#####################.#",
        "############################",
    ],
    5: [
        "################################",
        "#P..m..i.m..i.m..i.m..i.......#",
        "#.#####.#####.#####.#####.#####.#",
        "#.#.i.#.#.m.#.#.i.#.#.i.#.#.i.#.#",
        "#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
        "#.#.#.i.#.#.i.#.#.i.#.#.i.#.#.#.#",
        "#.#.#####.#####.#####.#####.#.#.#",
        "#.#.m.....m.....m.....m.....#.#.#",
        "#.#.#######################.#.#.#",
        "#.#.i.....................m.#.K.#",
        "#.###########################D###",
        "#.m.....i.......................#",
        "#..B.X.S#########################",
        "##################################",
    ]
}

